---
title: "Docker #4 - docker 핵심 명령어 모음(inspect, cp, --name, tag)"
description: 도커 이미지/컨테이너를 더 똑똑하게 다루기 위한 핵심 명령어 정리.
date: 2025-10-19 10:05:00 +0900
categories: [Docker, 컨테이너]
tags: [Docker, Container, inspect, cp, tag, 이름]
pin: false
---

## 도커 이미지 정보 출력 (docker image inspect)
`docker image inspect`는 이미지의 모든 설정과 메타데이터를 JSON으로 보여준다. 한마디로, 이 이미지가 어떻게 만들어졌고 어떤 환경에서 실행될지를 통째로 펼쳐보는 기능이다.

- **왜 필요한가**
  - **환경 확인**: 어떤 포트를 노출하는지, 기본 실행 명령(Entrypoint/Cmd)은 무엇인지, 기본 환경 변수는 무엇인지 즉시 확인 가능.
  - **구조 파악**: 이미지의 기반 OS, 레이어(Layers) 구성 등을 통해 Dockerfile 빌드 히스토리를 추적.
  - **최적화 힌트**: 어떤 레이어가 많이 변하는지 확인해 캐시 전략을 조정.

```bash
# 특정 이미지(이름 또는 ID)의 상세 정보
docker image inspect a1b2c3d4e5f6
```

예시 일부 출력은 다음과 같다.

```json
{
  "Config": {
    "ExposedPorts": { "80/tcp": {} },
    "Env": [ "PATH=/usr/local/sbin:..." ],
    "Entrypoint": [ "node", "server.js" ]
  },
  "Os": "linux",
  "RootFS": {
    "Type": "layers",
    "Layers": [
      "sha256:c921e0fe2...",
      "sha256:1a42bde9c..."
    ]
  }
}
```


## 컨테이너와 파일 교환 (docker cp)
`docker cp`는 실행 중인 컨테이너와 호스트 간에 파일/폴더를 복사하는 명령어이다. 컨테이너 내부를 들여다보거나 임시로 무언가를 넣고 싶을 때 유용하다.

- **왜 필요한가**
  - **로그/산출물 추출**: 컨테이너 내부에서 생성된 로그나 결과물을 빠르게 로컬로 가져옴.
  - **임시 설정 주입**: 디버깅 목적으로 설정 파일을 잠시 넣어 테스트.

중요한 점은, 애플리케이션 코드를 수정하고 이를 `docker cp`로 컨테이너에 덮어쓰는 방식은 권장되지 않는다. 변경 이력이 남지 않고 상태 일관성이 깨질 수 있다. 코드를 바꿨다면 이미지를 다시 빌드하고 컨테이너를 재생성하는 것이 정석이다.

```bash
# 로컬 → 컨테이너로 복사
docker cp [로컬 경로] [컨테이너 이름]:[컨테이너 내부 경로]

# 예) 내 컴퓨터의 dummy 폴더를 /app 아래로 복사
docker cp ./dummy my_container:/app

# 컨테이너 → 로컬로 복사
docker cp [컨테이너 이름]:[컨테이너 내부 경로] [로컬 경로]

# 예) 컨테이너의 /app/logs 폴더를 현재 폴더(.)로 복사
docker cp my_container:/app/logs .
```



## 컨테이너에 이름표 달기 (--name)
`docker run --name [원하는 이름]`을 쓰면 무작위 이름 대신 사람이 이해하기 쉬운 이름을 붙일 수 있다.

- **왜 필요한가**
  - `docker stop`, `restart`, `rm` 작업 때마다 긴 컨테이너 ID를 복사/붙여넣기 할 필요가 없다.
  - 팀에서 공통된 네이밍을 쓰면 목적과 역할이 한눈에 보인다.

```bash
# 'goals-app'이라는 이름으로 컨테이너 실행
docker run -p 3000:80 -d --rm --name goals-app my-image:latest

# 이제 이름으로 바로 제어 가능
docker stop goals-app
```


## 이미지 태깅 (name:tag)
`docker build -t [이름]:[태그] .` 형식으로 이미지에 의미 있는 이름과 버전을 붙일 수 있다. 긴 이미지 ID 대신 사람이 읽기 쉬운 주소를 부여하는 셈이다.

- **왜 필요한가**
  - **버전 관리**: `goals:latest`, `goals:1.0`, `goals:2.0-beta`처럼 동일 앱의 여러 버전을 명확히 구분.
  - **가독성/협업**: `node:14`, `my-app:latest`처럼 직관적인 참조가 가능해 명령이 읽기 쉬워짐.
  - **레지스트리 연동**: Docker Hub 등 레지스트리에 올리고 내릴 때 `이름:태그`가 주소 역할.

```bash
# 빌드 시 이름과 태그 부여
docker build -t goals:latest .

# 이름:태그로 컨테이너 실행
docker run --name goals-app goals:latest

# 이미 빌드된 이미지를 다른 태그로 추가 태깅
docker tag goals:latest goals:1.0
```

