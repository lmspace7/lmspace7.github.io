---
title: "Docker #1 - 기초 개념과 사용 이유"
description: Docker의 핵심 개념과 왜 사용하는지, VM과의 차이점, Dockerfile 명령어 정리
date: 2025-10-14 14:30:00 +0900
categories: [Docker, 컨테이너]
tags: [Docker, Container, Image, Dockerfile, 가상화]
pin: false
---

## 왜 도커(Docker)를 사용하는가?
도커는 기존 개발 및  운영 방식의 고질적인 문제를 해결하기 위해 등장했다.

* **내 컴퓨터에서는 잘되는데?**
  - 개발자마다 사용하는 운영체제, 라이브러리 버전이 달라 팀원의 컴퓨터나 실제 서버에서 코드가 동작하지 않는 문제가 빈번하게 발생한다.

* **의존성 지옥**
  - 여러 프로젝트를 하나의 컴퓨터에서 진행할 때 프로젝트 A는 같은 프레임워크의 낮은 버전이 필요하지만 프로젝트 B에서는 더 높은 버전이 필요로 할 수 있다.
  - **이때문에 서로 다른 버전의 도구나 라이브러리가 충돌할 수 있다.**

* **복잡한 배포 과정**
  - 새로운 서버에 애플리케이션을 배포하려면 필요한 모든 소프트웨어(웹, DB, ...)를 처음부터 다시 설치하고 설정해야 한다.
  - 이는 매우 번거로우며 실수의 여지가 있다.



### 도커의 해결 방식

* **환경의 표준화 및 격리**
  - 설계도를 통해 애플리케이션 실행환경을 코드로 명확하게 정의한다.
  - 이러한 설계도로 만들어진 컨테이너는 운영체제나 개인의 설정과 상관없이 어디서든 동일하게 동작한다.
  - > 이 설계도가 `Dockerfile`이다.

* **독립적인 실행환경**
  - 각 컨테이너는 자신만의 격리된 공간을 가진다.
  - 따라서 프로젝트 A와 B를 각각의 컨테이너에서 실행하면 **서로 다른 버전의 라이브러리가 충돌할 걱정 없이** 독립적으로 완벽하게 작동한다.

* **단순하고 신뢰성 있는 배포**
  - 잘 만들어진 도커 이미지만 있으면, 도커가 설치된 어떤 서버에서든 **명령어 하나로** 애플리케이션을 즉시 실행할 수 있다.
  - 이는 배포 과정을 극적으로 단순화하고 안정성을 높여준다.

**도커의 핵심 원리**

도커는 애플리케이션과 그 실행 환경 전체를 하나의 이미지로 **박제**한다.

* **예시**: Dockerfile에 "이 앱은 Python 3.11이 필요하고, 이런 라이브러리들을 설치해야 하며, 이 명령어를 실행해야 한다"는 코드를 명시적으로 작성하는 것과 같다.

* **결과**: 이렇게 만들어진 이미지는 완벽하게 격리된 상태로, 어떤 컴퓨터에서든 동일하게 작동하는 컨테이너를 만들어 낸다.

* **효과**: 
  - 개발, 테스트, 운영 서버 환경이 **100% 동일**해진다
  - 환경 차이로 인한 버그가 사라진다
  - 개발자는 더 이상 인프라 환경 설정에 신경쓰지 않고, **코드에만 집중**할 수 있게 된다


## 이미지(Image)와 컨테이너(Container), 도커(Docker)의 개념

* **이미지 (Image)**
  - > 설계도 또는 틀과 같다.
  - 애플리케이션을 실행하기 위한 모든 설정, 코드, 라이브러리를 담고 있는 **읽기 전용 템플릿**이다.
  - ```bash
    docker build  # 이미지 생성 명령어
    ```

* **컨테이너 (Container)**
  - > 소프트웨어를 실행하는 데 필요한 모든 것을 하나로 묶은 표준화된 실행 단위
  - 이미지라는 설계도를 바탕으로 실제 메모리에 올려 실행시킨 **제품 또는 실체**이다.
  - 하나의 이미지로 **여러 개의 컨테이너**를 동시에 실행할 수 있음
  - 각 컨테이너는 서로 격리되어 독립적으로 작동
  - ```bash
    docker run  # 컨테이너 생성 명령어
    ```

* **도커 (Docker)**
  - 컨테이너를 쉽게 만들고, 배포하고, 관리할 수 있도록 도와주는 **플랫폼이자 도구**이다.
  - 도커는 컨테이너 기술의 **사실 표준**으로 자리 잡았다.

## 가상 머신(VM) vs 도커 컨테이너

<img width="685" height="432" alt="Image" src="https://github.com/user-attachments/assets/067528f3-2d43-4cb9-82f3-0f5f532b2802" />

* **가상 머신 (Virtual Machine)**
  - 기존 운영체제(**HOST OS**) 위에 완전히 독립된 또 다른 운영체제(**Guest OS**)를 설치하여 가상의 컴퓨터를 만드는 기술이다.
  - **장점**: 환경을 완벽히 분리할 수 있음
  - **단점**: Guest OS 자체의 부피가 크고 무거워 시스템 자원(CPU, 메모리, 저장공간)을 많이 차지하며, 시작 속도가 느림

* **도커 컨테이너**
  - 호스트 OS의 커널을 공유하면서, 애플리케이션 실행에 필요한 부분만 격리하여 실행한다.
  - **장점**: 별도의 Guest OS를 설치하지 않기 때문에 매우 가볍고, 빠르며, 시스템 자원을 훨씬 효율적으로 사용

## 도커 아키텍처: 클라이언트와 데몬

도커는 클라이언트 - 서버 아키텍처를 사용한다.

<img width="1233" height="651" alt="Image" src="https://github.com/user-attachments/assets/9e1f0737-b48e-41e9-ad14-e19ef215eb13" />

* **클라이언트**
  - 터미널에 입력하는 `docker` 명령어가 클라이언트이다.
  - 데몬과 같은 시스템에 있을 수도 있고, 원격에 있는 데몬에 접속할 수도 있다.

* **도커 데몬 (Docker Daemon)**
  - 사용자가 도커와 상호작용하는 주된 창구이다.
  - `docker run`, `docker pull` 같은 명령어를 터미널에 입력하면, 클라이언트는 이 요청을 도커 데몬에게 전달한다.
  - 도커 API 요청을 수신하고, 이미지, 컨테이너, 네트워크, 볼륨과 같은 도커 객체를 관리한다.
  - 데몬은 다른 데몬과 통신해 도커 서비스를 관리할 수도 있다.


## 도커 레지스트리(Registry): 이미지 보관소

레지스트리는 도커 이미지를 저장하고 공유하는 공간이다.

<img width="1547" height="829" alt="Image" src="https://github.com/user-attachments/assets/2815ffdb-2f54-46ed-bb1a-b327e8937c2d" />

* **도커 허브 (Docker Hub)**
  - 도커사가 운영하는 공식 공개 레지스트리이다.
  - 전 세계 개발자들이 만든 수많은 공식 이미지(ubuntu, nginx, python, ...)가 저장되어 있어 누구나 쉽게 가져다 쓸 수 있다.

* **사설 레지스트리 (Private Registry)**
  - 회사 내부에서만 사용하거나 보안이 중요한 이미지를 관리하기 위해 직접 레지스트리를 구축하여 사용할 수도 있다.





## 마무리

이번 포스트에서는 도커의 기본 개념과 사용 이유, 핵심 구성 요소들에 대해 알아보았다. 
다음 포스트에서는 Dockerfile 작성법과 이미지 레이어, 캐싱 전략 등 더 심화된 내용을 다룰 예정이다.





















