---
title: 눈내리는 효과 구현 - SDF의 원리
description: VFX Graph에서 SDF로 파티클 충돌 처리 원리
date: 2025-09-10 23:00:00 +0900
categories: [Graphics]
tags: [SDF, VFX Graph, Unity, TextMeshPro]
pin: false
---

## 눈 내리는 효과과

프로젝트를 진행하다가 눈이 내리는 효과가 있고, 이게 특정 물체에 부딪히는 효과까지 자연스럽게 나와야 했다.

일단 눈은 작은 입자라서 파티클로 가는 게 맞고, 구현 수단으로는 Particle System이나 Visual Effect Graph(VFX Graph) 둘 다 후보였다. 그런데 바로 걸리는 게 충돌이었다. 파티클이 월드의 물체들과 어떻게 부딪히게 만들지? CPU에서 충돌을 돌리면 병목이 보이고, GPU에서 하려면 커스텀 Command Buffer 같은 걸로 직접 짜야 하나? (Command Buffer는 개념만 알고 실전으로는 안 써봤다)

그러다가 예전에 본 유니티 공식 VFX 튜토리얼에서 파티클 충돌 샘플이 있었던 게 번쩍 떠올랐다. 바로 깔아서 확인해 봤더니, 내가 원하는 목적과 거의 일치하는 샘플이 있었다.

![Collision Advanced](/assets/_post/Grahpics/Graphics/Collision%20Advanced.png)

색만 하얗게 바꾸고, 충돌체를 내가 원하는 물체로 바꾸면 바로 쓸 수 있겠더라.

그래서 충돌체 입력 노드를 보니 두 가지가 있었다. Mesh랑 SDF.

![Mesh 콜라이더 예시](/assets/_post/Grahpics/Graphics/HandMesh1.png)
![SDF 예시](/assets/_post/Grahpics/Graphics/SDF.png)

메시는 이미 준비돼 있어서 상관없었는데 SDF는 처음 들어봐서, 이게 뭔지부터 정리했다.

## SDF가 뭐길래 (Signed Distance Field)

정확히 말하면, 3D 파티클 충돌과 TextMeshPro의 2D 텍스트 렌더링은 영역이 다르지만 SDF의 핵심 원리는 같다. 2D에 쓰이느냐 3D에 쓰이느냐만 다를 뿐이다.

컴퓨터 그래픽스에서 형태를 표현하는 방식은 크게 둘이다.
- 명시적 표현: Vertex/Edge/Polygon으로 표면을 직접 정의한다. 즉 폴리곤 메시.
- 암시적 표현: 어떤 조건을 만족하는 점들의 집합으로 형태를 정의한다. 예를 들어 원점으로부터 거리가 R인 3차원 점들의 집합은 반지름 R인 구를 암시적으로 정의한다.

SDF는 이 암시적 표현의 정중앙에 있는 기술이다. 공간상의 모든 점 P에 대해, 그 점에서 가장 가까운 표면까지의 최단 거리값을 저장하고, 여기에 부호를 붙인다. 내부면 음수, 외부면 양수. 그래서 내부/외부 판정이 한 번에 된다.

이게 왜 좋냐면, 기존 명시적 표현(삼각형 단위 계산)으로 풀면 비싸고 복잡한 문제들이 SDF에서는 아주 단순한 거리 비교로 바뀐다.

- 예시: 어떤 점 P에서 SDF를 샘플링했더니 −0.2가 나왔다면, 그 점은 표면 안쪽으로 0.2만큼 들어와 있다는 뜻이다. 이 단순한 부호/크기 비교가 GPU 대량 병렬 처리에 너무 잘 맞는다.

## 해석적 SDF vs 이산적 SDF(베이킹)

- 해석적 SDF: 구, 상자, 원기둥 같은 기본 도형은 간결한 수식으로 SDF를 직접 계산할 수 있다. 셰이더에서 즉석 계산이 가능하고, 빠르고 메모리도 거의 안 든다.
- 이산적 SDF: 캐릭터나 복잡한 지형처럼 해석적 수식이 어려운 메시들은 격자(Grid)를 만들고 각 격자점에서의 SDF 값을 미리 계산해 저장한다. 이 과정을 베이킹(Baking)이라고 부른다. 결과물은 3D 텍스처 에셋이고, VFX Graph는 런타임에 이 3D 텍스처를 샘플링한다. 하드웨어 보간으로 자연스럽게 거리 필드가 재구성된다.

결국 한 줄 요약하면: “복잡한 메시가 정의하는 암시적 거리 함수를 샘플링해, GPU가 빠르게 읽을 수 있는 3D 텍스처로 바꾼 것”이 이산적 SDF다. 해상도가 오를수록 정확도는 올라가지만 메모리와 베이킹 시간이 더 든다.

## GPU 파티클 충돌에 SDF가 찰떡인 이유

전통적인 게임 물리는 CPU에 맞춰져 있다. 개별 객체끼리의 정밀한 상호작용엔 강하지만, VFX Graph처럼 수십만~수백만 파티클을 초당 처리하는 GPU 워크로드에는 안 맞는다. 핵심 문제는 CPU↔GPU 왕복 비용이다. 파티클 위치를 매 프레임 CPU로 보내 충돌을 검사하고, 다시 결과를 GPU로 돌려보내는 건 실시간에 맞추기 어렵다.

그래서 답은 “처음부터 끝까지 GPU 안에서 끝내는 것”이다. SDF는 읽기 전용 3D 텍스처라서, 수천 개 스레드가 동시에 빠르게 샘플링할 수 있다. 충돌 판정도 단순하다.

```text
distance = sdfTexture.Sample(particle_position)
```

- distance ≤ 0이면 콜라이더 내부 → 충돌로 간주
- distance > 0이면 외부 → 통과

이걸 파티클마다 병렬로 돌리면 끝이다. 삼각형-삼각형 같은 무거운 기하 연산 없이, 텍스처 읽기 + 비교만으로 충돌 처리가 된다.

## 장단점 비교

| 항목 | SDF 기반 충돌 (VFX Graph) | 전통적 Mesh Collider (CPU 물리) |
|---|---|---|
| 성능 (GPU) | 매우 높음. 파티클당 텍스처 1회 읽기로 끝. 대규모 병렬에 이상적. | 낮음. GPU 워크로드에 직접 사용 불가, CPU 왕복 비용 큼. |
| 메모리 | 중간~높음. 3D 텍스처 해상도에 비례. | 낮음~중간. 삼각형 수에 비례. |
| 정확도 | 근사치. 해상도 한계, 얇은 형상 누락/모서리 둥글어짐, 터널링 가능. | 폴리곤 정확도. 메시 기반 정밀 충돌. |
| 설정 비용 | 베이킹 필요. 고해상도는 시간/디스크 비용 큼. | 낮음. 콜라이더에 메시만 할당. |
| 동적 유연성 | 제한적. 정적 지오메트리에 적합. 실시간 생성은 비용 큼. | 높음. 동적/변형 리지드바디에도 적용 쉬움. |

## 언제 무엇을 쓸까

- 정적 지오메트리에 맞는 대량 파티클 충돌: SDF 추천.
- 얇은 형상, 정밀 접촉, 터널링 방지가 중요: 메시/CPU 물리 고려.
- 하이파이 시각 효과지만 성능이 더 중요한 경우: SDF 해상도(메모리)와 결과 정확도 사이 트레이드오프를 잡으면 된다.

## Unity에서 SDF 쓰는 간단 흐름(VFX Graph)

1) 소스 메시 준비 → 2) SDF 베이킹(전용 툴/임포터) → 3) VFX Graph에서 SDF 콜라이더 노드에 3D 텍스처 할당 → 4) 파티클 업데이트 스테이지에서 SDF 충돌 반응 적용(반사, 슬라이드, 킬 등)

핵심은 “GPU에서 텍스처 한 번 읽고 부호 비교”라는 단순함이다. 그래서 눈, 비, 파편 같은 대규모 파티클 충돌에 특히 유리하다.

## 마치면서

이번에 눈 충돌 효과를 구현하면서, 메시 콜라이더 대신 SDF를 쓰면 GPU 워크로드에 얼마나 잘 들어맞는지 체감했다. 원리는 단순하지만 효과는 확실하다. 필요한 정확도/메모리/베이킹 시간을 저울질해서, 상황에 맞게 SDF 해상도만 잘 잡아주면 된다.


