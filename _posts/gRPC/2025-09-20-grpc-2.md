---
title: 유니티에서 gRPC 사용하기 2 - YYAH 패키지와 결합
description: Unity에서 grpc-dotnet + YAHH로 gRPC 활성화
date: 2025-09-20 16:30:00 +0900
categories: [유니티 인증서버, gRPC]
tags: [Unity, gRPC, HTTP/2, grpc-dotnet, YetAnotherHttpHandler]
pin: false
---

2025년 3분기 기준으로 최신 gRPC 프레임워크는 Unity의 네이티브 지원이 부재하다. 이유는 단순하다. grpc-dotnet이 요구하는 HTTP/2를 Unity의 기본 네트워킹 스택이 지원하지 않는다. 그래서 일단 결론부터 말하자면 지금은 YetAnotherHttpHandler(YAHH)로 해결하는 게 가장 깔끔하다.

- [https://github.com/Cysharp/YetAnotherHttpHandler](https://github.com/Cysharp/YetAnotherHttpHandler)

이를 사용하면 양방향 스트리밍을 포함한 gRPC의 모든 기능을 우수한 성능으로 Unity 환경에서 사용할 수 있다.

## 전제 조건 - HTTP/2 
gRPC는 HTTP/2를 기반으로 구축된 RPC 프레임워크로, 단일 TCP 연결을 통해 여러 요청을 동시에 처리하는 멀티플렉싱과 같은 고급 기능을 제공한다. .NET gRPC 클라이언트 라이브러리는 이러한 기능을 활용하기 위한 기반이 되는 HTTP 공급자가 반드시 HTTP/2를 지원해야한다.

하지만 실제로 유니티에서 그냥 단순히 gRPC 관련 패키지들을 설치하고, 실행을 하려고 하면 아래와 같은 오류가 발생할 것이다.

<img width="936" height="285" alt="Image" src="https://github.com/user-attachments/assets/b8858bf4-c4b4-4930-bd55-25f072f92498" />

이것은 바로 Unity의 내장 네트워킹 스택이 HTTP/2를 지원하지 않기 때문이다.
이러한 근본적인 비호환성은 gRPC 자체의 결함이라기보다는 두 기술 생태계의 발전 속도 차이에서 비롯되었다고 할 수 있다.
Unity는 자체적으로 수정한 Mono 런타임 포크를 오랫동안 사용해 왔으며, 점진적으로 최신 .NET 표준을 도입해 왔다. 
반면 주류 .NET 생태계는 HTTP/2나 다른 기술들을 신속하게 채택했다. 이러한 발전 속도의 차이로 인해 Unity 개발자들은 네이티브 라이브러리 지원 측면에서 순수 .NET 개발자들보다 뒤처지게 되었고, 이 간극을 메우기 위해 커뮤니티의 해결책이나 서드파티 라이브러리가 필요하게 된 것이다.


## 업데이트 (2025-09-24)

이 글을 포스팅하고 얼마 지나지 않아 유니티 코리아 공식 유튜브에서 관련 언급이 있었다.
Unity 6.3 Beta부터 HTTP/2 지원이 추가된다고 밝혔다. 하지만 이 지원이 엔진 내부의 어떤 계층까지 포함되는지는 아직 명확하지 않아, 현시점에서 YetAnotherHttpHandler(YAHH)를 완전히 대체할 수 있을지는 미지수다.


- 참고: [Unity Korea 유튜브 6.3 Beta 세션(HTTP/2 언급, 19:55)](https://www.youtube.com/watch?v=nNpIrMWvEjw&t=1195s)

<img width="1005" height="450" alt="Image" src="https://github.com/user-attachments/assets/97dc5684-2bb0-40c1-8279-65a18660416c" />


### YAHH가 왜 필요한가

- [https://github.com/Cysharp/YetAnotherHttpHandler](https://github.com/Cysharp/YetAnotherHttpHandler)

YetAnotherHttpHandler(YAHH)는 Unity 및 기타 .NET Standard 환경에 고성능 HTTP/2 클라이언트 기능을 제공하는 라이브러리다. 핵심 네트워킹 클라이언트를 수많은 상용 서비스에서 검증된 Rust 라이브러리인 hyper와 rustls 기반으로 구현하고, 이를 네이티브 인터페이스로 C#에 노출한다. 

이 라이브러리는 HttpMessageHandler의 드롭인(drop-in) 대체재이므로 표준 HttpClient와 자연스럽게 통합되고, 가장 중요하게는 Grpc.Net.Client의 GrpcChannel과 매끄럽게 연동된다. 

정리하면, YAHH는 Unity에 없는 HTTP/2 런타임을 제공한다. 그래서 grpc-dotnet이 돌아간다. Rust(hyper, rustls) 코어 + C# 래퍼 구조라 빠르고 안정적이다.


## 대안 프레임워크 - MagicOnion
MagicOnion은 gRPC를 기반으로 구축된 고수준 RPC 프레임워크라고 한다. .proto 파일을 사용하지 않는 코드 우선 접근 방식이며, 별도의 서비스 계약 정의를 대신해 서버와 클라이언트 간에 공유되는 C# 인터페이스를 직접 사용한다.

- [https://github.com/Cysharp/MagicOnion](https://github.com/Cysharp/MagicOnion)
나중에 기회가 된다면 한번 사용해봐야겠다.

## 참고 자료
- [https://stackoverflow.com/questions/72907696/how-to-get-grpc-working-between-a-unity-game-client-c-net-and-tonic-rust-b](https://stackoverflow.com/questions/72907696/how-to-get-grpc-working-between-a-unity-game-client-c-net-and-tonic-rust-b)
- [https://github.com/grpc/grpc-dotnet/issues/1309](https://github.com/grpc/grpc-dotnet/issues/1309)
- [https://unity.com/kr/blog/engine-platform/unity-and-net-whats-next](https://unity.com/kr/blog/engine-platform/unity-and-net-whats-next)
- [https://github.com/Cysharp/YetAnotherHttpHandler/issues/2](https://github.com/Cysharp/YetAnotherHttpHandler/issues/2)